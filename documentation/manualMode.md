# Manual Mode

## Documentation by a forgetful German

### Preface

This documentation describes the Yu-Gi-Oh! manual dueling simulator I wrote. It is using Primus in order to communicate between server and client.

Described below is only the server-side state manager.

#### Lines 1 - 86

- Initialize the requirements. This includes:
    * `require`-ing Primus and Primus rooms
    * Setting up a server on port `55542` (the original port `24555` reversed)
    * Setting up:
        1. User registry
        2. Active duel state (in format:
        ```
        {
            duelID:
            {
                options:
                {
                    banlist: banlistPropertyName,
                    database: databasePropertyName
                },
                players:
                {
                    uid:
                    {
                        ROLE: playerRole,
                        deck: parsedYDK
                    }
                },
                spectators:
                {
                    uid:
                    {
                        ROLE: ROLE_SPECTATOR
                    }
                }
            }
        }
        ```
        3. ConfigParser
        4. Databases and banlist objects
    * Setting various constants (those should be usually self-explanatory, and if they ever aren't I will describe them)
    * Call `cdbUpdater` and `banlistUpdater()`, then refresh them every 120 seconds
- Handle users connecting, handle user input and user disconnects through callbacks. More below.

#### `handlePrimusEvent(data, client)` (L88 - L693)
##### Function parameters
- `data`: Data object being passed by Primus
- `client`: Reference to Primus' current client

This is the core logic of the server-side state manager. All the commands are received and executed here, and the internal state is modified here as well.

Data sent by the client will be in this object format:

```
{
    action: commandName,
    uid: userID,
    username: username,
    duelID: currentDuel,
    duelQuery: commandConstant,
    amount: amountInt,
    phase: currentPhase,
    target: {
        player: playerRole,
        location: locationConstant,
        slot: arrayIndex
        /*, locations: [locationConstants*] */
    },
    moveTo: {
        player: playerRole,
        location: locationConstant,
        slot: arrayIndex
    },
    hostOptions: {
        deckList: parsedYDK,
        database: databasePropertyName,
        banList: banListPropertyName
    }
}
```

Below a list of all accepted input for `data.action`:

- `"registerUID"`
- `"hostDuel"`
- `"joinDuel"`
- `"spectateDuel"`
- `"duelQuery"`
- `"heartBeat"`
- `"regDuelLog"`

`data.uid` is the user's (technically not guaranteed to be unique) user ID: it is generated by a client-side function (although I will likely change this at a later point); and it is used for all purposes of verification at the moment.

`data.username` is the user's chosen nick name and will be displayed for everyone.

`data.duelID` is a property name of the currently on-going duel which will be looked for in `activeDuels`.

Based on the `data.action`, program flow will branch:

- `"registerUID"`
    * Store the user's `data.uid` and `data.username` in the `registry` object.
    * `return;`
- `"hostDuel"`
    * Creates a new duel in `activeDuels` based on the contents of `data.hostOptions`. Format for `hostOptions` is available above.
    * This action will fail if the passed `deckList` is invalid. If `database` is not a valid property name, the default database will be used.
    * `return;`
- `"joinDuel"`
    * Checks the user's `data.hostOptions.deckList` for validity and if it succeeds, joins the user into the specified `data.duelID`.
    * Assigns a role based on how many participants are currently playing.
    * `return;`
    (I'm aware the switch can be optimized)
- `"spectateDuel"`
    * Joins the user into the `data.duelID` and assigns spectator role.
    * `return;`
- `"duelQuery"`
    * Handles a query regarding the current `data.duelID`
    * More below.
- `"heartBeat"`
    * Simple keep-alive request
    * `return;`
- `"regDuelLog"`
    * Writes the current `activeDuels` and `registry` objects to the client.
    * Only used during development. Will be removed once this hits live, or at least will be made inaccessible to any non-staff.
    * `return;`

#### `handleClientDisconnect(client)` (L695 - 711)
##### Function parameters
- `client`: Same client reference as for `handlePrimusEvent`

Simply handles the event in which a user disconnects. Write the event to all the clients listening to that user's duels and delete them.

A disconnect is final. Primus itself will handle short network interrupts, but once it can't reconnect anymore, the user has died to the server.

#### `writeResponse(client, dataArray)` (L713 - 720)
##### Function parameters
- `client`: Client reference
- `dataArray`: Array with 2 to 3 elements which is used to form the response

Surprisingly one of the few comments describe the parameters this function accepts.

Simply writes a response to the passed client. Responses will be written only in the `handlePrimusEvent` method.

#### `secureClientDuel(activeDuel)` (L722 - 745)
##### Function parameters
- `activeDuel`: Object reference to a currently on-going duel in `activeDuels`

Prepare an object containing the current duel, then extract the UIDs and replace them with user names. Used when initiating a duel.

#### `validDeck(deckList, banList, database)` (L747 - 816)
##### Function parameters
- `deckList`: Object created by `parseYDK` representing the user's deck list
- `banList`: Property of `banLists`
- `database`: Property of `databases`

Check a deck for its validity. This check will only return `true` if the following criteria matches:

- Minimum amount of 40 cards in the main deck
- Maximum amount of 60 cards in the main deck
- Minimum amount of 0 cards in the side and extra deck
- Maximum amount of 15 cards in the side and extra deck
- Card is contained in the banlist and the copies of the card do not exceed the maximum allowed amount
- Card and all of its aliases are contained a maximum of 3 times (this still needs to be fixed since card aliases are not checked in the previous checks)

#### `commandIsValid(activeDuel, uid, target, moveTo)` (L818 - 820)
##### Function parameters
- `activeDuel`: Object reference to a currently on-going duel in `activeDuels`
- `uid`: User ID as string
- `target`: Object describing the command's targeted card
- `moveTo`: Object describing the command's card's new location

A one-liner. Contains overly unnecessary optimized boolean condition for checking if the `target` card is owned by the user issuing the command, if it's in place and if the `moveTo` location and slot is not empty.

#### `xyzSummonIsValid(activeDuel, uid, target, moveTo` (L822 - 849)
##### Function parameters
- `activeDuel`: Object reference to a currently on-going duel in `activeDuels`
- `uid`: User ID as string
- `target`: Object describing the command's targeted cards
- `moveTo`: Object describing the command's cards' new location

Checks if an Xyz Summon is being performed properly. Contains similar checks to above function. However, the format is different than usual: `[XYZ_TARGET, XYZ_MATERIAL_1 /*, XYZ_MATERIAL_2, etc. */]`

#### `changePositionIsValid(activeDuel, uid, target)` (L851 - 853)
##### Function parameters
- `activeDuel`: Object reference to a currently on-going duel in `activeDuels`
- `uid`: User ID as string
- `target`: Object describing the command's targeted card

Similar one-liner to #L818. Changing a card's position uses the same command as the other movement commands so state is checked if the command is valid.

#### `GameState(nPlayers)` (L855 - 876)
##### Function parameters
- `nPlayers`: Integer assigning how many players should be present in the new game state

Initialize a game state object for `nPlayers` amount of players. Pretty straightforward, use default empty values and 8000 LP.

#### `startDuelState(gameState, deckList)` (L878 - 908)
##### Function parameters
- `gameState`: Object created by `GameState`
- `deckList`: Object created by `parseYDK` representing the user's deck list

In a specific `gameState`, fill it with the contents of `deckList`.

Afterwards, shuffle the deck and move 5 cards from the top of the deck to the hand. More about those below.

#### `moveCard(move)` (L910 - 916)
##### Function parameters
- `move`: Object containing references to target and destination locations

Passed an object `move` with `move.from` and `move.to`, the card object will be moved from `from` to `to` (I think this was obvious)

#### `moveCards(amount, move)` (L918 - 934)
##### Function parameters
- `amount`: Integer describing how many cards should be moved
- `move`: Object containing references to target and destination locations

Move `amount` of cards from either the top or the bottom of `move.from` to `move.to`. The direction is specified through `move.dir`, if `move.dir === 0` it will move from the top, and if it is any other value it will move from the bottom.

#### `shuffleArray(array)` (L936 - 948)
##### Function parameters
- `array`: Any array to be shuffled

Generic shuffle function.

#### `shuffleDeck(activeDuel, player)` (L950 - 952)
##### Function parameters
- `activeDuel`: Object reference to a currently on-going duel in `activeDuels`
- `player`: Integer assigning a target player whose deck will be shuffled

Shuffles a user's deck. Simple.

#### `cdbUpdater()` (L954 - 969)
##### Function parameters
- None

For every database that has been initialized, look up the file residing in the local file system at `../http/manifest/`; this is architecture-specific and might need to be adjusted if files are moved around.

#### `banListUpdater()` (L971 - 983)
##### Function parameters
- None

Update the banlist from the configuration file found in the local file system at `../http/ygopro/`.